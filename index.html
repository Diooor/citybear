<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D 白日城市熊大跑酷 | Daytime Brown City 3D</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+TC:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --day-sky: #87ceeb;
    --day-sun: #fff9e6;
    --neon-pink: #ff2d95;
    --neon-yellow: #f8d800;
    --ui-dark: #222;
  }

  body {
    background: var(--day-sky);
    font-family: 'Orbitron', 'Noto Sans TC', sans-serif;
    overflow: hidden;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    color: var(--ui-dark);
  }

  #gameWrapper {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #87ceeb;
  }

  /* UI 介面層 */
  #ui-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
    padding: 20px;
  }

  .stats-container { display: flex; justify-content: space-between; }
  
  .stat-box .label { font-size: 10px; color: #333; letter-spacing: 2px; font-weight: 700; }
  .stat-box .value { font-size: 24px; font-weight: 900; color: #000; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); }
  
  #highscore-val { color: var(--neon-pink); }

  #combo-display {
    position: absolute; top: 80px; right: 20px; text-align: right;
    opacity: 0; transition: transform 0.3s, opacity 0.3s; transform: scale(0.5);
  }
  #combo-display.active { opacity: 1; transform: scale(1); }
  #combo-display .value { color: #d6b300; font-size: 20px; font-weight: 900; text-shadow: 1px 1px 0px #fff; }

  /* 螢幕覆蓋層 (開始/結束) */
  .overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(255, 255, 255, 0.7);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 20; transition: opacity 0.5s; backdrop-filter: blur(8px);
  }
  .overlay.hidden { opacity: 0; pointer-events: none; }

  h1 { 
    font-size: clamp(32px, 8vw, 56px); letter-spacing: 8px; margin-bottom: 10px; color: #222;
    text-shadow: 2px 2px 0px #fff, 0 0 10px rgba(0,0,0,0.1); 
  }
  .subtitle { color: #555; margin-bottom: 30px; letter-spacing: 4px; font-weight: 700; }

  .btn {
    padding: 15px 40px; font-family: 'Orbitron', sans-serif; font-weight: 700;
    background: #333; color: #fff; border: none; border-radius: 4px;
    cursor: pointer; transition: 0.3s; letter-spacing: 2px; pointer-events: all;
    box-shadow: 0 4px 0px #000;
  }
  .btn:hover { background: #000; transform: translateY(-2px); box-shadow: 0 6px 0px #000; }
  .btn:active { transform: translateY(0px); box-shadow: 0 2px 0px #000; }

  #gameover-screen .btn { background: var(--neon-pink); color: #fff; box-shadow: 0 4px 0px #900; }

  .hint { margin-top: 30px; font-size: 12px; color: #333; text-align: center; line-height: 1.8; font-weight: 700; }

  /* 手機控制面板 */
  #mobile-controls {
    position: absolute; bottom: 30px; width: 100%;
    display: none; justify-content: space-around; padding: 0 20px; z-index: 15;
  }
  .m-btn {
    width: 64px; height: 64px; border: 2px solid rgba(0,0,0,0.2);
    border-radius: 50%; display: flex; align-items: center; justify-content: center;
    font-size: 20px; background: rgba(255,255,255,0.5); pointer-events: all; color: #000;
  }
  @media (max-width: 768px) { #mobile-controls { display: flex; } }
</style>
</head>
<body>

<div id="gameWrapper">
  <div id="ui-layer">
    <div class="stats-container">
      <div class="stat-box">
        <div class="label">最高紀錄 BEST</div>
        <div class="value" id="highscore-val">0</div>
      </div>
      <div class="stat-box" style="text-align: right;">
        <div class="label">目前分數 SCORE</div>
        <div class="value" id="score-val">0</div>
      </div>
    </div>
    <div id="combo-display">
      <div class="value" id="combo-val">×0 COMBO</div>
    </div>
  </div>

  <div id="start-screen" class="overlay">
    <h1>CITY BROWN</h1>
    <div class="subtitle">3D 白 日 城市 跑 酷</div>
    <button class="btn" id="startBtn">開始任務 START</button>
    <div class="hint">
      [ ↑ / 空白鍵 ] 二段式跳躍 (附空翻動畫)<br>
      [ ↓ ] 滑行過低處 | [ ← → ] 自由橫移躲避
    </div>
  </div>

  <div id="gameover-screen" class="overlay hidden">
    <div style="color: #000; letter-spacing: 4px; margin-bottom: 10px; font-weight: 900;">任務失敗 MISSION FAILED</div>
    <div id="final-score" style="font-size: 40px; font-weight: 900; margin-bottom: 30px; color: var(--neon-pink);">0</div>
    <button class="btn" id="restartBtn">再試一次 RETRY</button>
  </div>

  <div id="mobile-controls">
    <div class="m-btn" id="m-left">←</div>
    <div class="m-btn" id="m-up">↑</div>
    <div class="m-btn" id="m-down">↓</div>
    <div class="m-btn" id="m-right">→</div>
  </div>
</div>

<script>
/**
 * 音效引擎
 */
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.bgmPlaying = false;
    this.seqId = null;
    this.master = null;
  }
  init() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.2;
    this.master.connect(this.ctx.destination);
  }
  startBGM() {
    this.init(); if (this.bgmPlaying) return;
    this.bgmPlaying = true;
    const ac = this.ctx;
    const step = 60 / 125 / 2;
    let beat = 0;
    const notes = [261.63, 293.66, 329.63, 349.23, 392.00];

    this.seqId = setInterval(() => {
      if (this.ctx.state === 'suspended') this.ctx.resume();
      const t = ac.currentTime;
      if (beat % 4 === 0) {
        const o = ac.createOscillator(); const g = ac.createGain();
        o.type = 'triangle'; o.frequency.setValueAtTime(notes[Math.floor(beat/8)%notes.length], t);
        g.gain.setValueAtTime(0.15, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.15);
        o.connect(g); g.connect(this.master); o.start(t); o.stop(t+0.2);
      }
      beat++;
    }, step * 1000);
  }
  stopBGM() { clearInterval(this.seqId); this.bgmPlaying = false; }
  playSfx(freq, type='sine', dur=0.2) {
    if (!this.ctx) return;
    if (this.ctx.state === 'suspended') this.ctx.resume();
    const t = this.ctx.currentTime;
    const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
    o.type = type; o.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(0.25, t); g.gain.exponentialRampToValueAtTime(0.01, t+dur);
    o.connect(g); g.connect(this.master); o.start(t); o.stop(t+dur);
  }
}

const audio = new AudioEngine();

/**
 * 遊戲主程式
 */
let scene, camera, renderer, clock;
let playerGroup, bodyParts = {}; 
let obstacles = [], coins = [], buildings = [];
let gridLine; // 定義全域 gridLine
let gameState = 'start';
let score = 0, highScore = localStorage.getItem('parkour3d_high') || 0;
let combo = 0, comboTimer = 0;

const INITIAL_SPEED = 0.17;
const MAX_SPEED = 0.52;
let currentSpeed = INITIAL_SPEED;

const gravity = -0.015;
const jumpForce = 0.38;
let playerVY = 0;
let jumpCount = 0;
let isSliding = false;
let slideTimer = 0;

let targetX = 0;
const moveSpeed = 0.16;
const laneWidth = 4.8;
let flipRotation = 0;

function createBrownBear() {
  const group = new THREE.Group();
  const brownMat = new THREE.MeshStandardMaterial({ color: 0x63422b, roughness: 0.8 }); 
  const earMat = new THREE.MeshStandardMaterial({ color: 0x523624 });
  const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const blackMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.9, 16), brownMat);
  body.position.y = 0.75;
  group.add(body);
  bodyParts.body = body;

  const headGroup = new THREE.Group();
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.65, 16, 16), brownMat);
  headGroup.add(head);
  headGroup.position.y = 1.6;
  group.add(headGroup);
  bodyParts.headGroup = headGroup;

  const earGeo = new THREE.SphereGeometry(0.18, 8, 8);
  const leftEar = new THREE.Mesh(earGeo, earMat);
  leftEar.position.set(-0.5, 0.45, 0);
  headGroup.add(leftEar);
  const rightEar = new THREE.Mesh(earGeo, earMat);
  rightEar.position.set(0.5, 0.45, 0);
  headGroup.add(rightEar);

  const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.26, 12, 12), whiteMat);
  muzzle.scale.set(1, 0.8, 0.5);
  muzzle.position.set(0, -0.15, 0.55);
  headGroup.add(muzzle);

  const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
  const leftEye = new THREE.Mesh(eyeGeo, blackMat);
  leftEye.position.set(-0.2, 0.1, 0.62);
  headGroup.add(leftEye);
  const rightEye = new THREE.Mesh(eyeGeo, blackMat);
  rightEye.position.set(0.2, 0.1, 0.62);
  headGroup.add(rightEye);

  const limbGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.6, 8);
  const leftArm = new THREE.Mesh(limbGeo, brownMat);
  leftArm.position.set(-0.65, 1.0, 0);
  group.add(leftArm);
  bodyParts.leftArm = leftArm;
  const rightArm = new THREE.Mesh(limbGeo, brownMat);
  rightArm.position.set(0.65, 1.0, 0);
  group.add(rightArm);
  bodyParts.rightArm = rightArm;

  const leftLeg = new THREE.Mesh(limbGeo, brownMat);
  leftLeg.position.set(-0.25, 0.3, 0);
  group.add(leftLeg);
  bodyParts.leftLeg = leftLeg;
  const rightLeg = new THREE.Mesh(limbGeo, brownMat);
  rightLeg.position.set(0.25, 0.3, 0);
  group.add(rightLeg);
  bodyParts.rightLeg = rightLeg;

  return group;
}

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  scene.fog = new THREE.Fog(0x87ceeb, 20, 95);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 5, 12.5); 
  camera.lookAt(0, 2, -5);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x87ceeb);
  document.getElementById('gameWrapper').appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const sun = new THREE.DirectionalLight(0xfff9e6, 1.3);
  sun.position.set(10, 25, 15);
  scene.add(sun);

  const trackMat = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 0.9 });
  const track = new THREE.Mesh(new THREE.PlaneGeometry(14, 200), trackMat);
  track.rotation.x = -Math.PI / 2;
  scene.add(track);

  gridLine = new THREE.GridHelper(100, 40, 0x44aaee, 0x77bbff);
  gridLine.position.y = 0.02;
  scene.add(gridLine);

  playerGroup = createBrownBear();
  scene.add(playerGroup);

  for(let i=0; i<45; i++) spawnBuilding(true);

  window.addEventListener('resize', onWindowResize);
  clock = new THREE.Clock();
  animate();
}

function spawnBuilding(randomZ = false) {
  const h = 12 + Math.random() * 40;
  const w = 6 + Math.random() * 12;
  const bMat = new THREE.MeshStandardMaterial({ color: Math.random() > 0.5 ? 0xdddddd : 0xbbbbbb, roughness: 0.8 });
  const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), bMat);
  const side = Math.random() > 0.5 ? 1 : -1;
  b.position.set(side * (20 + Math.random() * 20), h/2, randomZ ? -Math.random() * 160 : -160);
  
  const winGeo = new THREE.BoxGeometry(0.1, 0.8, 0.5);
  const winMat = new THREE.MeshStandardMaterial({ color: 0xaaccdd });
  for(let i=0; i<6; i++) {
    const win = new THREE.Mesh(winGeo, winMat);
    win.position.set(side < 0 ? w/2 : -w/2, h - 3 - i*4, (Math.random()-0.5)*w*0.8);
    b.add(win);
  }
  scene.add(b);
  buildings.push(b);
}

function spawnObstacle() {
  const type = Math.random();
  let obs;
  const laneX = (Math.random() - 0.5) * 9.5; 

  if (type < 0.4) {
    obs = new THREE.Mesh(new THREE.BoxGeometry(3.5, 1.4, 1), new THREE.MeshStandardMaterial({ color: 0xee3355 }));
    obs.position.set(laneX, 0.7, -100);
    obs.userData = { w: 3.5, h: 1.4, d: 1 };
  } else if (type < 0.75) {
    obs = new THREE.Mesh(new THREE.BoxGeometry(6, 1.5, 1), new THREE.MeshStandardMaterial({ color: 0x2277bb }));
    obs.position.set(laneX, 3.6, -100); 
    obs.userData = { w: 6, h: 1.5, d: 1 };
  } else {
    obs = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 2), new THREE.MeshStandardMaterial({ color: 0x555555 }));
    obs.position.set(laneX, 4, -100);
    obs.userData = { w: 2, h: 8, d: 2 };
  }
  scene.add(obs);
  obstacles.push(obs);
}

function spawnCoin() {
  const coin = new THREE.Mesh(new THREE.TorusGeometry(0.38, 0.1, 12, 24), new THREE.MeshStandardMaterial({ color: 0xffcc00 }));
  coin.position.set((Math.random()-0.5)*10, 1.5 + Math.random()*4, -100);
  scene.add(coin);
  coins.push(coin);
}

function animateBrown() {
  const t = clock.getElapsedTime() * currentSpeed * 50;
  if (gameState !== 'playing') return;

  if (!isSliding && jumpCount === 0) {
    const swing = Math.sin(t * 0.25);
    bodyParts.leftArm.rotation.x = swing * 1.2;
    bodyParts.rightArm.rotation.x = -swing * 1.2;
    bodyParts.leftLeg.rotation.x = -swing * 1.0;
    bodyParts.rightLeg.rotation.x = swing * 1.0;
    bodyParts.headGroup.rotation.z = swing * 0.1;
    playerGroup.position.y = Math.abs(Math.cos(t * 0.25)) * 0.22; 
    playerGroup.rotation.x = 0; 
  } else if (jumpCount > 0) {
    bodyParts.leftLeg.rotation.x = -0.8;
    bodyParts.rightLeg.rotation.x = 0.4;
    bodyParts.leftArm.rotation.x = 1.5;
    bodyParts.rightArm.rotation.x = 1.5;
    if (jumpCount === 2) {
      flipRotation += 0.22;
      playerGroup.rotation.x = flipRotation < Math.PI * 2 ? -flipRotation : 0;
    }
  } else if (isSliding) {
    bodyParts.leftLeg.rotation.x = -Math.PI / 1.8;
    bodyParts.rightLeg.rotation.x = -Math.PI / 1.8;
    bodyParts.leftArm.rotation.x = -Math.PI / 4;
    bodyParts.rightArm.rotation.x = -Math.PI / 4;
    playerGroup.rotation.x = 0.2; 
  }
}

function handleInput(type) {
  if (gameState !== 'playing') return;
  if (type === 'up') {
    if (jumpCount < 2) {
      playerVY = jumpForce;
      jumpCount++;
      isSliding = false;
      playerGroup.scale.y = 1;
      if (jumpCount === 2) flipRotation = 0;
      audio.playSfx(400 + jumpCount * 120);
    }
  } else if (type === 'down') {
    if (jumpCount === 0 && !isSliding) {
      isSliding = true;
      slideTimer = 50;
      audio.playSfx(220);
    }
  } else if (type === 'left') {
    targetX = Math.max(-laneWidth, targetX - 3.2);
  } else if (type === 'right') {
    targetX = Math.min(laneWidth, targetX + 3.2);
  }
}

function update() {
  if (gameState !== 'playing') return;

  currentSpeed = Math.min(MAX_SPEED, INITIAL_SPEED + score * 0.0000035);
  score += 1.2;
  document.getElementById('score-val').innerText = Math.floor(score/10);

  playerGroup.position.x += (targetX - playerGroup.position.x) * moveSpeed;
  playerVY += gravity;
  playerGroup.position.y += playerVY;

  if (playerGroup.position.y <= 0) {
    playerGroup.position.y = 0;
    playerVY = 0;
    jumpCount = 0;
    flipRotation = 0;
    playerGroup.rotation.x = 0;
  }

  if (isSliding) {
    playerGroup.scale.y = 0.55;
    slideTimer--;
    if (slideTimer <= 0) { isSliding = false; playerGroup.scale.y = 1; }
  }

  animateBrown();

  buildings.forEach(b => {
    b.position.z += currentSpeed * 0.9;
    if (b.position.z > 20) b.position.z = -160;
  });

  if (gridLine) {
    gridLine.position.z = (gridLine.position.z + currentSpeed) % 2.5;
  }

  if (Math.floor(score) % 90 === 0) spawnObstacle();
  if (Math.floor(score) % 150 === 0) spawnCoin();

  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];
    obs.position.z += currentSpeed;
    const dx = Math.abs(playerGroup.position.x - obs.position.x);
    const dy = Math.abs((playerGroup.position.y + (isSliding ? 0.45 : 1.1)) - obs.position.y);
    const dz = Math.abs(playerGroup.position.z - obs.position.z);
    const hitW = (1.4 + obs.userData.w) / 2;
    const hitH = ((isSliding ? 0.9 : 2.2) + obs.userData.h) / 2;
    const hitD = (1.2 + obs.userData.d) / 2;
    if (dx < hitW && dy < hitH && dz < hitD) gameOver();
    if (obs.position.z > 25) { scene.remove(obs); obstacles.splice(i, 1); }
  }

  for (let i = coins.length - 1; i >= 0; i--) {
    const coin = coins[i];
    coin.position.z += currentSpeed;
    coin.rotation.y += 0.12;
    if (playerGroup.position.distanceTo(coin.position) < 2.3) { 
      score += 1000; combo++; comboTimer = 110;
      audio.playSfx(1100 + combo * 60);
      showCombo();
      scene.remove(coin); coins.splice(i, 1);
    } else if (coin.position.z > 25) { scene.remove(coin); coins.splice(i, 1); }
  }

  if (comboTimer > 0) {
    comboTimer--;
    if (comboTimer === 0) { combo = 0; document.getElementById('combo-display').classList.remove('active'); }
  }
}

function showCombo() {
  const el = document.getElementById('combo-display');
  document.getElementById('combo-val').innerText = `×${combo} COMBO`;
  el.classList.add('active');
}

function gameOver() {
  gameState = 'gameover';
  audio.stopBGM();
  audio.playSfx(120, 'sawtooth', 0.8);
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('parkour3d_high', highScore);
    document.getElementById('highscore-val').innerText = Math.floor(highScore/10);
  }
  document.getElementById('final-score').innerText = Math.floor(score/10);
  document.getElementById('gameover-screen').classList.remove('hidden');
}

function startGame() {
  score = 0; combo = 0; currentSpeed = INITIAL_SPEED;
  targetX = 0;
  playerGroup.position.set(0, 0, 0);
  playerGroup.scale.y = 1;
  playerGroup.rotation.x = 0;
  playerVY = 0; isSliding = false;
  jumpCount = 0; flipRotation = 0;
  obstacles.forEach(o => scene.remove(o)); obstacles = [];
  coins.forEach(c => scene.remove(c)); coins = [];
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('gameover-screen').classList.add('hidden');
  gameState = 'playing';
  audio.startBGM();
}

function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

document.getElementById('startBtn').onclick = startGame;
document.getElementById('restartBtn').onclick = startGame;

window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') handleInput('up');
  if (e.code === 'ArrowDown' || e.code === 'KeyS') handleInput('down');
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') handleInput('left');
  if (e.code === 'ArrowRight' || e.code === 'KeyD') handleInput('right');
});

document.getElementById('m-up').ontouchstart = (e) => { e.preventDefault(); handleInput('up'); };
document.getElementById('m-down').ontouchstart = (e) => { e.preventDefault(); handleInput('down'); };
document.getElementById('m-left').ontouchstart = (e) => { e.preventDefault(); handleInput('left'); };
document.getElementById('m-right').ontouchstart = (e) => { e.preventDefault(); handleInput('right'); };

window.onload = () => {
  init();
  document.getElementById('highscore-val').innerText = Math.floor(highScore/10);
};
</script>
</body>
</html>